// // 恰逢H国国庆，国王邀请n位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这n位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。

// 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。

// 格式
// 输入格式
// 第一行包含一个整数n，表示大臣的人数。
// 第二行包含两个整数a和b，之间用一个空格隔开，分别表示国王左手和右手上的整数。接下来n行，每行包含两个整数a和b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。

// 输出格式
// 输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。

// 题解
// 可以通过比较两个相邻的大臣不同顺序对结果的影响，从而判断两个相邻大臣的顺序，而且可以发现a，b的交换只会影响a，b本身获得的金币，并不会影响其他大臣获得的金币数
// 假设两个大臣a和b的左手和右手的的数字分别为（x1, y1）和（x2， y2），两位大臣前面所有人左手的和为S，交换前两个大臣获得的最多的金币是max(S/y1，S*x1/y2), 交换后两个大臣获得的最多的金币是(S/y2, S*x2/y1)，如果要使交换后更优（即交换后获得最大金币更小），因为S/y1小于S*x2/y1，S*x1/y2 大于 S/y2，只要S*x1/y2 大于S*x2/y1即可，稍微化简一下可得x1*y1大于x2*y2，所以左右手乘积大的值放在后面更优；
// 依据这个逻辑可以推导得到，最优的队伍里，第1位大臣的左右手乘积小于第2位大臣左右手乘积，第2位小于第3位，从而只需要根据走右手乘积从小到大排序即可得到最优队伍顺序；

#include <bits/stdc++.h>
using namespace std;
#define ll long long

struct people{
    int left, right;
};

void solve()
{
    int n;
    cin>>n;
    int king[2];
    cin>>king[0]>>king[1];
    vector<people> peo = vector<people>(n);
    for(int i = 0;i < n;++i){
        cin>>peo[i].left>>peo[i].right;
    }
    sort(peo.begin(), peo.end(), [](people &a, people &b){return a.left*a.right < b.left*b.right;});
    
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr); 
    solve();
    return 0;
}

